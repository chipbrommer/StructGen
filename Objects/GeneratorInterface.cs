using System.Collections.Generic;
using System.Text;
using Newtonsoft.Json;
using CsvHelper;
using System.IO;
using Xceed.Document.NET;
using Xceed.Words.NET;
using System.Xml.Serialization;
using System;

namespace StructGen.Objects
{
    public class GeneratorInterface
    {
        readonly static string autogenHeader =
        "/////////////////////////////////////////////////////////////////\r\n" +
        "//! This file is auto-generated by StructGen \r\n" +
        "/////////////////////////////////////////////////////////////////\r\n\n";

        /// <summary>enum for available header types that can be created.</summary>
        public enum HEADER_TYPE
        {
            C,
            CPP,
            CSHARP,
        }

        /// <summary>enum for acceptable variable types.</summary>
        static readonly List<string> validTypes = new()
        {
            "int",
            "int8_t",
            "int16_t",
            "int32_t",
            "unsigned int",
            "uint",
            "uint8_t",
            "uint16_t",
            "uint32_t",
            "float",
            "double",
            "std::string",
            "string",
            "char",
            "unsigned char",
            "signed char",
        };

        /// <summary>Handles CSV file input.</summary>
        /// <param name="filepath"> -[in]- Filepath of the file to parse.</param>
        /// <returns>Parsed HeaderFile structure.</returns>
        public static HeaderFile HandleCsvFile(string filepath)
        {
            return new HeaderFile();
        }

        /// <summary>Handles JSON file input.</summary>
        /// <param name="filepath"> -[in]- Filepath of the file to parse.</param>
        /// <returns>Parsed HeaderFile structure.</returns>
        public static HeaderFile HandleJsonFile(string filepath)
        {
            try
            {
                string json = File.ReadAllText(filepath);
                var deserializedObject = JsonConvert.DeserializeObject<HeaderFile>(json);

                if (deserializedObject != null)
                {
                    return deserializedObject;
                }
                else
                {
                    return new HeaderFile();
                }
            }
            catch
            {
                return new HeaderFile();
            }
        }

        /// <summary>Handles XML file input.</summary>
        /// <param name="filepath"> -[in]- Filepath of the file to parse.</param>
        /// <returns>Parsed HeaderFile structure.</returns>
        public static HeaderFile HandleXmlFile(string filepath)
        {
            try
            {
                string xml = File.ReadAllText(filepath);

                XmlSerializer serializer = new(typeof(HeaderFile));

                using StringReader reader = new(xml);
                HeaderFile headerFile = (HeaderFile)serializer.Deserialize(reader);

                if (headerFile != null)
                {
                    return headerFile;
                }
                else
                {
                    return new HeaderFile();
                }
            }
            catch
            {
                return new HeaderFile();
            }
        }

        /// <summary>Validates the variables in a file structure are acceptable.</summary>
        /// <param name="file"> -[in]- File structure to be validated.</param>
        /// <returns>A list of variable names with improper types.</returns>
        private static List<string> ValidateVariableTypes(HeaderFile file)
        {
            List<string> invalidVariables = new();

            foreach (var structure in file.Structures)
            {
                foreach (var variable in structure.Variables)
                {
                    if (!validTypes.Contains(variable.Type))
                    {
                        invalidVariables.Add(variable.Name);
                    }
                }
            }

            return invalidVariables;
        }

        /// <summary>Creates a header for C language.</summary>
        /// <param name="file"> -[in]- File structure to be created.</param>
        /// <returns>string of output file content.</returns>
        public static string GenerateHeaderC(HeaderFile file)
        {
            StringBuilder output = new();

            output.AppendLine(autogenHeader);

            List<string> invalidVars = ValidateVariableTypes(file);

            if (invalidVars.Count == 0)
            {
                foreach (var structure in file.Structures)
                {
                    // Define the structure
                    output.AppendLine($"/* {structure.StructureComment} */");
                    output.AppendLine($"struct {structure.StructureName}");
                    output.AppendLine("{");

                    // Define variables
                    foreach (var variable in structure.Variables)
                    {
                        output.AppendLine($"    {variable.Type} {variable.Name}; /* {variable.Comment} */");
                    }

                    // Close the structure definition
                    output.AppendLine("};");
                }
            }
            else
            {
                // respond with which variables are invalid
                output.AppendLine("\n\nBad input file variable types on variables:\n");

                foreach (var invalidVar in invalidVars)
                {
                    output.AppendLine(invalidVar);
                }
            }

            return output.ToString();
        }

        /// <summary>Creates a header for C++ language.</summary>
        /// <param name="file"> -[in]- File structure to be created.</param>
        /// <returns>string of output file content.</returns>
        public static string GenerateHeaderCPP(HeaderFile file)
        {
            StringBuilder output = new();

            output.AppendLine(autogenHeader);
            output.AppendLine("/////////////////////////////////////////////////////////////////");
            output.Append($"//\t@project: {file.FileInformation.ProjectName}\r\n");
            output.Append($"//\t@name:    {file.FileInformation.FileName}\r\n");   
            output.Append($"//\t@version: {file.FileInformation.FileVersion}\r\n");
            output.AppendLine("/////////////////////////////////////////////////////////////////");
            output.AppendLine("#include <string>");
            output.AppendLine("#include <cstdint>");
            output.AppendLine("");

            List<string> invalidVars = ValidateVariableTypes(file);

            if (invalidVars.Count == 0)
            {
                foreach (var structure in file.Structures)
                {
                    bool packed = false;
                    // Define the structure
                    output.AppendLine($"/// @brief {structure.StructureComment}");

                    // Check if Packing is not "0" and not empty
                    if (!string.IsNullOrEmpty(structure.StructurePacking) && structure.StructurePacking != "0")
                    {
                        // Define the structure with custom packing
                        output.AppendLine($"#pragma pack(push,{structure.StructurePacking})");
                        packed = true;
                    }

                    output.AppendLine($"struct {structure.StructureName}");
                    output.AppendLine("{");

                    // Define variables
                    foreach (var variable in structure.Variables)
                    {
                        output.AppendLine($"    {variable.Type} {variable.Name}; // {variable.Comment}");
                    }

                    // Close the structure definition
                    output.AppendLine("};");

                    if(packed)
                    {
                        output.AppendLine($"#pragma pack(pop)");
                    }

                    output.AppendLine("");
                }
            }
            else
            {
                // respond with which variables are invalid
                output.AppendLine("\n\nBad input file variable types on variables:\n");

                foreach (var invalidVar in invalidVars)
                {
                    output.AppendLine(invalidVar);
                }
            }

            return output.ToString();
        }

        /// <summary>Creates a header for C# language.</summary>
        /// <param name="file"> -[in]- File structure to be created.</param>
        /// <returns>string of output file content.</returns>
        public static string GenerateHeaderCSHARP(HeaderFile file)
        {
            StringBuilder output = new();

            output.AppendLine(autogenHeader);
            output.AppendLine("using System;");
            output.AppendLine("using System.Runtime.InteropServices;");
            output.AppendLine("");

            List<string> invalidVars = ValidateVariableTypes(file);

            if (invalidVars.Count == 0)
            {
                foreach (var structure in file.Structures)
                {
                    // Define the structure 
                    output.AppendLine($"/// <summary> {structure.StructureComment} </summary>");
                    output.AppendLine($"[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]");
                    output.AppendLine($"public struct {structure.StructureName}");
                    output.AppendLine("{");

                    // Define variables
                    foreach (var variable in structure.Variables)
                    {
                        output.AppendLine($"    public {variable.Type} {variable.Name}; // {variable.Comment}");
                    }

                    // Close the structure definition
                    output.AppendLine("}");
                }
            }
            else
            {
                // respond with which variables are invalid
                output.AppendLine("\n\nBad input file variable types on variables:\n");

                foreach (var invalidVar in invalidVars)
                {
                    output.AppendLine(invalidVar);
                }
            }

            return output.ToString();
        }

        /// <summary>Creates a "File Description Document" based on the HeaderFile.</summary>
        /// <param name="file"> -[in]- HeaderFile structure to create document from.</param>
        /// <param name="outputPath"> -[in]- Path to save the file to.</param>
        public static int GenerateFileDescriptionDocument(HeaderFile file, string outputPath)
        {
            // Create a new Word document
            var doc = DocX.Create($"{file.FileInformation.FileName} - File Description Document");

            foreach (var structure in file.Structures)
            {
                // Add a heading for the structure
                doc.InsertParagraph($"Structure: {structure.StructureName}").FontSize(14).Alignment = Alignment.left;
                doc.InsertParagraph($"Information: {structure.AdditionalInformation}").FontSize(14).Alignment = Alignment.left;

                // Create a table for structure details
                var table = doc.AddTable(1, 3);
                table.Design = TableDesign.MediumShading1Accent1; // Optional: Apply a table design

                // Set column widths
                table.SetWidthsPercentage(new[] { 20f, 30f, 50f });

                // Add table headers
                table.Rows[0].Cells[0].Paragraphs[0].Append("Item Number").Bold();
                table.Rows[0].Cells[1].Paragraphs[0].Append("Item Name").Bold();
                table.Rows[0].Cells[2].Paragraphs[0].Append("Item Description").Bold();

                int itemNumber = 1;

                foreach (var variable in structure.Variables)
                {
                    // Add data rows to the table
                    var row = table.InsertRow();
                    row.Cells[0].Paragraphs[0].Append(itemNumber.ToString());
                    row.Cells[1].Paragraphs[0].Append(variable.Name);
                    row.Cells[2].Paragraphs[0].Append(variable.Comment);
                    itemNumber++;
                }

                // Insert the table into the document
                doc.InsertTable(table);

                // Insert a spacer paragraph between tables
                doc.InsertParagraph().SpacingAfter(20);
            }

            // Save the document
            string fileName = $"{file.FileInformation.FileName} - Rev {file.DescriptionDocument.Revision} - File Description Document.docx";
            string filePath = System.IO.Path.Combine(outputPath, fileName);
            doc.SaveAs(filePath);

            return 0;
        }

        /// <summary>Parse a C++ Header file into a HeaderFile structure</summary>
        /// <param name="filepath"> -[in]- string containing the filepath to open/read</param>
        /// <returns>HeaderFile structure containing the parsed contents/returns>
        public static HeaderFile ParseCppHeaderFile(string filepath)
        {
            HeaderFile headerFile = new();

            string content = File.ReadAllText(filepath);

            // Split the content into lines
            string[] lines = content.Split('\n');

            bool parsingStructure = false;
            Structure structure = new();

            foreach (string line in lines)
            {
                if(!parsingStructure)
                {
                    // Process each line and extract relevant information
                    if (line.Contains("@project:"))
                    {
                        headerFile.FileInformation.ProjectName = line.Split(':')[1].Trim();
                    }
                    else if (line.Contains("@name:"))
                    {
                        headerFile.FileInformation.FileName = line.Split(':')[1].Trim();
                    }
                    else if (line.Contains("@version:"))
                    {
                        headerFile.FileInformation.FileVersion = line.Split(':')[1].Trim();
                    }
                    else if (line.Contains("struct"))
                    {
                        structure.StructureName = line.Split(' ')[2];
                        structure.StructureComment = lines[Array.IndexOf(lines, line) - 1].Trim().Trim('/');
                        parsingStructure = true;
                    }
                }
                else
                {
                    // If end of structure is found, handle clean up
                    if (line.Trim() == "}")
                    {
                        headerFile.Structures.Add(structure);
                        structure = new();
                        parsingStructure = false; 
                    }
                    else
                    {
                        // Process variables inside the structure
                        // Example: "string Name; // The name of the person"
                        string[] parts = line.Trim().Split(' ');
                        if (parts.Length >= 2)
                        {
                            string type = parts[0];
                            string name = parts[1].Split(';')[0]; // Remove the semicolon
                            string comment = line.Split("//")[1].Trim(); // Extract the comment

                            // Create a new Variable object and add it to the current structure
                            structure.Variables.Add(new Variable
                            {
                                Name = name,
                                Type = type,
                                Comment = comment
                            });
                        }
                    }
                }
            }

            return headerFile;
        }

        /// <summary>Parse a C# Header file into a HeaderFile structure</summary>
        /// <param name="csHeaderContent"> -[in]- string containing the file contents</param>
        /// <returns>HeaderFile structure containing the parsed contents/returns>
        public static HeaderFile ParseCsharpHeaderFile(string csHeaderContent)
        {
            HeaderFile headerFile = new();

            // @todo - handle cs file parsing. 

            return headerFile;
        }
    }
}
