using System.Collections.Generic;
using System.Text;
using Newtonsoft.Json;
using CsvHelper;
using System.IO;
using Word = Microsoft.Office.Interop.Word;

namespace StructGen.Objects
{
    public class GeneratorInterface
    {
        readonly static string autogenHeader =
        "/////////////////////////////////////////////////////////////////\r\n" +
        "//! This file is auto-generated by StructGen \r\n" +
        "/////////////////////////////////////////////////////////////////\r\n\n";

        /// <summary>enum for available header types that can be created.</summary>
        public enum HEADER_TYPE
        {
            C,
            CPP,
            CSHARP,
        }

        /// <summary>enum for acceptable variable types.</summary>
        static readonly List<string> validTypes = new List<string>
        {
            "int",
            "int8_t",
            "int16_t",
            "int32_t",
            "unsigned int",
            "uint",
            "uint8_t",
            "uint16_t",
            "uint32_t",
            "float",
            "double",
            "std::string",
            "string",
            "char",
            "unsigned char",
            "signed char",
        };

        /// <summary>Handles CSV file input.</summary>
        /// <param name="filepath"> -[in]- Filepath of the file to parse.</param>
        /// <returns>Parsed HeaderFile structure.</returns>
        public static HeaderFile HandleCsvFile(string filepath)
        {
            return new HeaderFile();
        }

        /// <summary>Handles JSON file input.</summary>
        /// <param name="filepath"> -[in]- Filepath of the file to parse.</param>
        /// <returns>Parsed HeaderFile structure.</returns>
        public static HeaderFile HandleJsonFile(string filepath)
        {
            string json = File.ReadAllText(filepath);
            return JsonConvert.DeserializeObject<HeaderFile>(json);
        }

        /// <summary>Handles XML file input.</summary>
        /// <param name="filepath"> -[in]- Filepath of the file to parse.</param>
        /// <returns>Parsed HeaderFile structure.</returns>
        public static HeaderFile HandleXmlFile(string filepath)
        {
            return new HeaderFile();
        }

        /// <summary>Validates the variables in a file structure are acceptable.</summary>
        /// <param name="file"> -[in]- File structure to be validated.</param>
        /// <returns>A list of variable names with improper types.</returns>
        private static List<string> ValidateVariableTypes(HeaderFile file)
        {
            List<string> invalidVariables = new List<string>();

            foreach (var structure in file.Structures)
            {
                foreach (var variable in structure.Variables)
                {
                    if (!validTypes.Contains(variable.Type))
                    {
                        invalidVariables.Add(variable.Name);
                    }
                }
            }

            return invalidVariables;
        }

        /// <summary>Creates a header for C language.</summary>
        /// <param name="file"> -[in]- File structure to be created.</param>
        /// <returns>string of output file content.</returns>
        public static string GenerateHeaderC(HeaderFile file)
        {
            StringBuilder output = new StringBuilder();

            output.AppendLine(autogenHeader);

            List<string> invalidVars = ValidateVariableTypes(file);

            if (invalidVars.Count == 0)
            {
                foreach (var structure in file.Structures)
                {
                    // Define the structure
                    output.AppendLine($"/* {structure.StructureComment} */");
                    output.AppendLine($"struct {structure.StructureName}");
                    output.AppendLine("{");

                    // Define variables
                    foreach (var variable in structure.Variables)
                    {
                        output.AppendLine($"    {variable.Type} {variable.Name}; /* {variable.Comment} */");
                    }

                    // Close the structure definition
                    output.AppendLine("};");
                }
            }
            else
            {
                // respond with which variables are invalid
                output.AppendLine("\n\nBad input file variable types on variables:\n");

                foreach (var invalidVar in invalidVars)
                {
                    output.AppendLine(invalidVar);
                }
            }

            return output.ToString();
        }

        /// <summary>Creates a header for C++ language.</summary>
        /// <param name="file"> -[in]- File structure to be created.</param>
        /// <returns>string of output file content.</returns>
        public static string GenerateHeaderCPP(HeaderFile file)
        {
            StringBuilder output = new StringBuilder();

            output.AppendLine(autogenHeader);
            output.AppendLine("/////////////////////////////////////////////////////////////////");
            output.Append($"//\t@project: {file.File.ProjectName}\r\n");
            output.Append($"//\t@name:    {file.File.FileName}\r\n");   
            output.Append($"//\t@version: {file.File.FileVersion}\r\n");
            output.AppendLine("/////////////////////////////////////////////////////////////////");
            output.AppendLine("#include <string>");
            output.AppendLine("#include <cstdint>");
            output.AppendLine("");

            List<string> invalidVars = ValidateVariableTypes(file);

            if (invalidVars.Count == 0)
            {
                foreach (var structure in file.Structures)
                {
                    bool packed = false;
                    // Define the structure
                    output.AppendLine($"/// @brief {structure.StructureComment}");

                    // Check if Packing is not "0" and not empty
                    if (!string.IsNullOrEmpty(structure.StructurePacking) && structure.StructurePacking != "0")
                    {
                        // Define the structure with custom packing
                        output.AppendLine($"#pragma pack(push,{structure.StructurePacking})");
                        packed = true;
                    }

                    output.AppendLine($"struct {structure.StructureName}");
                    output.AppendLine("{");

                    // Define variables
                    foreach (var variable in structure.Variables)
                    {
                        output.AppendLine($"    {variable.Type} {variable.Name}; // {variable.Comment}");
                    }

                    // Close the structure definition
                    output.AppendLine("};");

                    if(packed)
                    {
                        output.AppendLine($"#pragma pack(pop)");
                    }

                    output.AppendLine("");
                }
            }
            else
            {
                // respond with which variables are invalid
                output.AppendLine("\n\nBad input file variable types on variables:\n");

                foreach (var invalidVar in invalidVars)
                {
                    output.AppendLine(invalidVar);
                }
            }

            return output.ToString();
        }

        /// <summary>Creates a header for C# language.</summary>
        /// <param name="file"> -[in]- File structure to be created.</param>
        /// <returns>string of output file content.</returns>
        public static string GenerateHeaderCSHARP(HeaderFile file)
        {
            StringBuilder output = new StringBuilder();

            output.AppendLine(autogenHeader);
            output.AppendLine("using System;");
            output.AppendLine("using System.Runtime.InteropServices;");
            output.AppendLine("");

            List<string> invalidVars = ValidateVariableTypes(file);

            if (invalidVars.Count == 0)
            {
                foreach (var structure in file.Structures)
                {
                    // Define the structure 
                    output.AppendLine($"/// <summary> {structure.StructureComment} </summary>");
                    output.AppendLine($"[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]");
                    output.AppendLine($"public struct {structure.StructureName}");
                    output.AppendLine("{");

                    // Define variables
                    foreach (var variable in structure.Variables)
                    {
                        output.AppendLine($"    public {variable.Type} {variable.Name}; // {variable.Comment}");
                    }

                    // Close the structure definition
                    output.AppendLine("}");
                }
            }
            else
            {
                // respond with which variables are invalid
                output.AppendLine("\n\nBad input file variable types on variables:\n");

                foreach (var invalidVar in invalidVars)
                {
                    output.AppendLine(invalidVar);
                }
            }

            return output.ToString();
        }

        /// <summary>Creates a "File Description Document" based on the HeaderFile.</summary>
        /// <param name="file"> -[in]- HeaderFile structure to create document from.</param>
        /// <param name="outputPath"> -[in]- Path to save the file to.</param>
        public static void GenerateFileDescriptionDocument(HeaderFile file, string outputPath)
        {
            // Create a new Word application and document
            Word.Application wordApp = new Word.Application();
            Word.Document doc = wordApp.Documents.Add();

            // Iterate through the structures and create a table for each
            foreach (var structure in file.Structures)
            {
                // Create a new table
                Word.Table table = doc.Tables.Add(doc.Range(), 1, 3); // 1 row, 3 columns
                table.Borders.Enable = 1; // Enable table borders

                // Add table headers
                table.Cell(1, 1).Range.Text = "Item Number";
                table.Cell(1, 2).Range.Text = "Item Name";
                table.Cell(1, 3).Range.Text = "Item Description";

                // Set table column widths
                table.Columns[1].Width = 50; // Adjust as needed
                table.Columns[2].Width = 150; // Adjust as needed
                table.Columns[3].Width = 300; // Adjust as needed

                // Add structure details to the table
                int itemNumber = 1;

                foreach (var variable in structure.Variables)
                {
                    table.Rows.Add();
                    table.Cell(itemNumber + 1, 1).Range.Text = itemNumber.ToString();
                    table.Cell(itemNumber + 1, 2).Range.Text = variable.Name;
                    table.Cell(itemNumber + 1, 3).Range.Text = variable.Comment;
                    itemNumber++;
                }

                // Add structure name as a title
                Word.Paragraph title = doc.Paragraphs.Add();
                title.Range.Text = $"Structure: {structure.StructureName}";
                title.Range.Bold = 1; // Make it bold
                title.Range.Font.Size = 14; // Set font size
                title.Alignment = Word.WdParagraphAlignment.wdAlignParagraphCenter; // Center-align
                title.Range.InsertParagraphAfter();

                // Release the table COM object to avoid memory leaks
                System.Runtime.InteropServices.Marshal.ReleaseComObject(table);
            }

            // Save the document
            string fileName = $"{file.File.FileName} - Rev {file.DescDoc.Revision} - File Description Document.docx";
            string filePath = System.IO.Path.Combine(outputPath, fileName);
            doc.SaveAs2(filePath);

            // Close Word application
            wordApp.Quit();

            // Release COM objects to avoid memory leaks
            System.Runtime.InteropServices.Marshal.ReleaseComObject(doc);
            System.Runtime.InteropServices.Marshal.ReleaseComObject(wordApp);
        }

    }
}
