using System.Collections.Generic;
using System.Text;
using Newtonsoft.Json;
using CsvHelper;
using System.IO;
using Xceed.Document.NET;
using Xceed.Words.NET;

namespace StructGen.Objects
{
    public class GeneratorInterface
    {
        readonly static string autogenHeader =
        "/////////////////////////////////////////////////////////////////\r\n" +
        "//! This file is auto-generated by StructGen \r\n" +
        "/////////////////////////////////////////////////////////////////\r\n\n";

        /// <summary>enum for available header types that can be created.</summary>
        public enum HEADER_TYPE
        {
            C,
            CPP,
            CSHARP,
        }

        /// <summary>enum for acceptable variable types.</summary>
        static readonly List<string> validTypes = new List<string>
        {
            "int",
            "int8_t",
            "int16_t",
            "int32_t",
            "unsigned int",
            "uint",
            "uint8_t",
            "uint16_t",
            "uint32_t",
            "float",
            "double",
            "std::string",
            "string",
            "char",
            "unsigned char",
            "signed char",
        };

        /// <summary>Handles CSV file input.</summary>
        /// <param name="filepath"> -[in]- Filepath of the file to parse.</param>
        /// <returns>Parsed HeaderFile structure.</returns>
        public static HeaderFile HandleCsvFile(string filepath)
        {
            return new HeaderFile();
        }

        /// <summary>Handles JSON file input.</summary>
        /// <param name="filepath"> -[in]- Filepath of the file to parse.</param>
        /// <returns>Parsed HeaderFile structure.</returns>
        public static HeaderFile HandleJsonFile(string filepath)
        {
            string json = File.ReadAllText(filepath);
            return JsonConvert.DeserializeObject<HeaderFile>(json);
        }

        /// <summary>Handles XML file input.</summary>
        /// <param name="filepath"> -[in]- Filepath of the file to parse.</param>
        /// <returns>Parsed HeaderFile structure.</returns>
        public static HeaderFile HandleXmlFile(string filepath)
        {
            return new HeaderFile();
        }

        /// <summary>Validates the variables in a file structure are acceptable.</summary>
        /// <param name="file"> -[in]- File structure to be validated.</param>
        /// <returns>A list of variable names with improper types.</returns>
        private static List<string> ValidateVariableTypes(HeaderFile file)
        {
            List<string> invalidVariables = new List<string>();

            foreach (var structure in file.Structures)
            {
                foreach (var variable in structure.Variables)
                {
                    if (!validTypes.Contains(variable.Type))
                    {
                        invalidVariables.Add(variable.Name);
                    }
                }
            }

            return invalidVariables;
        }

        /// <summary>Creates a header for C language.</summary>
        /// <param name="file"> -[in]- File structure to be created.</param>
        /// <returns>string of output file content.</returns>
        public static string GenerateHeaderC(HeaderFile file)
        {
            StringBuilder output = new StringBuilder();

            output.AppendLine(autogenHeader);

            List<string> invalidVars = ValidateVariableTypes(file);

            if (invalidVars.Count == 0)
            {
                foreach (var structure in file.Structures)
                {
                    // Define the structure
                    output.AppendLine($"/* {structure.StructureComment} */");
                    output.AppendLine($"struct {structure.StructureName}");
                    output.AppendLine("{");

                    // Define variables
                    foreach (var variable in structure.Variables)
                    {
                        output.AppendLine($"    {variable.Type} {variable.Name}; /* {variable.Comment} */");
                    }

                    // Close the structure definition
                    output.AppendLine("};");
                }
            }
            else
            {
                // respond with which variables are invalid
                output.AppendLine("\n\nBad input file variable types on variables:\n");

                foreach (var invalidVar in invalidVars)
                {
                    output.AppendLine(invalidVar);
                }
            }

            return output.ToString();
        }

        /// <summary>Creates a header for C++ language.</summary>
        /// <param name="file"> -[in]- File structure to be created.</param>
        /// <returns>string of output file content.</returns>
        public static string GenerateHeaderCPP(HeaderFile file)
        {
            StringBuilder output = new StringBuilder();

            output.AppendLine(autogenHeader);
            output.AppendLine("/////////////////////////////////////////////////////////////////");
            output.Append($"//\t@project: {file.File.ProjectName}\r\n");
            output.Append($"//\t@name:    {file.File.FileName}\r\n");   
            output.Append($"//\t@version: {file.File.FileVersion}\r\n");
            output.AppendLine("/////////////////////////////////////////////////////////////////");
            output.AppendLine("#include <string>");
            output.AppendLine("#include <cstdint>");
            output.AppendLine("");

            List<string> invalidVars = ValidateVariableTypes(file);

            if (invalidVars.Count == 0)
            {
                foreach (var structure in file.Structures)
                {
                    bool packed = false;
                    // Define the structure
                    output.AppendLine($"/// @brief {structure.StructureComment}");

                    // Check if Packing is not "0" and not empty
                    if (!string.IsNullOrEmpty(structure.StructurePacking) && structure.StructurePacking != "0")
                    {
                        // Define the structure with custom packing
                        output.AppendLine($"#pragma pack(push,{structure.StructurePacking})");
                        packed = true;
                    }

                    output.AppendLine($"struct {structure.StructureName}");
                    output.AppendLine("{");

                    // Define variables
                    foreach (var variable in structure.Variables)
                    {
                        output.AppendLine($"    {variable.Type} {variable.Name}; // {variable.Comment}");
                    }

                    // Close the structure definition
                    output.AppendLine("};");

                    if(packed)
                    {
                        output.AppendLine($"#pragma pack(pop)");
                    }

                    output.AppendLine("");
                }
            }
            else
            {
                // respond with which variables are invalid
                output.AppendLine("\n\nBad input file variable types on variables:\n");

                foreach (var invalidVar in invalidVars)
                {
                    output.AppendLine(invalidVar);
                }
            }

            return output.ToString();
        }

        /// <summary>Creates a header for C# language.</summary>
        /// <param name="file"> -[in]- File structure to be created.</param>
        /// <returns>string of output file content.</returns>
        public static string GenerateHeaderCSHARP(HeaderFile file)
        {
            StringBuilder output = new StringBuilder();

            output.AppendLine(autogenHeader);
            output.AppendLine("using System;");
            output.AppendLine("using System.Runtime.InteropServices;");
            output.AppendLine("");

            List<string> invalidVars = ValidateVariableTypes(file);

            if (invalidVars.Count == 0)
            {
                foreach (var structure in file.Structures)
                {
                    // Define the structure 
                    output.AppendLine($"/// <summary> {structure.StructureComment} </summary>");
                    output.AppendLine($"[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]");
                    output.AppendLine($"public struct {structure.StructureName}");
                    output.AppendLine("{");

                    // Define variables
                    foreach (var variable in structure.Variables)
                    {
                        output.AppendLine($"    public {variable.Type} {variable.Name}; // {variable.Comment}");
                    }

                    // Close the structure definition
                    output.AppendLine("}");
                }
            }
            else
            {
                // respond with which variables are invalid
                output.AppendLine("\n\nBad input file variable types on variables:\n");

                foreach (var invalidVar in invalidVars)
                {
                    output.AppendLine(invalidVar);
                }
            }

            return output.ToString();
        }

        /// <summary>Creates a "File Description Document" based on the HeaderFile.</summary>
        /// <param name="file"> -[in]- HeaderFile structure to create document from.</param>
        /// <param name="outputPath"> -[in]- Path to save the file to.</param>
        public static int GenerateFileDescriptionDocument(HeaderFile file, string outputPath)
        {
            // Create a new Word document
            var doc = DocX.Create($"{file.File.FileName} - File Description Document");

            foreach (var structure in file.Structures)
            {
                // Add a heading for the structure
                doc.InsertParagraph($"Structure: {structure.StructureName}").FontSize(14).Alignment = Alignment.left;
                doc.InsertParagraph($"Information: {structure.AdditionalInformation}").FontSize(14).Alignment = Alignment.left;

                // Create a table for structure details
                var table = doc.AddTable(1, 3);
                table.Design = TableDesign.MediumShading1Accent1; // Optional: Apply a table design

                // Set column widths
                table.SetWidthsPercentage(new[] { 20f, 30f, 50f });

                // Add table headers
                table.Rows[0].Cells[0].Paragraphs[0].Append("Item Number").Bold();
                table.Rows[0].Cells[1].Paragraphs[0].Append("Item Name").Bold();
                table.Rows[0].Cells[2].Paragraphs[0].Append("Item Description").Bold();

                int itemNumber = 1;

                foreach (var variable in structure.Variables)
                {
                    // Add data rows to the table
                    var row = table.InsertRow();
                    row.Cells[0].Paragraphs[0].Append(itemNumber.ToString());
                    row.Cells[1].Paragraphs[0].Append(variable.Name);
                    row.Cells[2].Paragraphs[0].Append(variable.Comment);
                    itemNumber++;
                }

                // Insert the table into the document
                doc.InsertTable(table);

                // Insert a spacer paragraph between tables
                doc.InsertParagraph().SpacingAfter(20);
            }

            // Save the document
            string fileName = $"{file.File.FileName} - Rev {file.DescDoc.Revision} - File Description Document.docx";
            string filePath = System.IO.Path.Combine(outputPath, fileName);
            doc.SaveAs(filePath);

            return 0;
        }

    }
}
