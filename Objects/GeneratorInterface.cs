using System.Collections.Generic;
using System.Text;
using Newtonsoft.Json;
using CsvHelper;
using System.IO;

namespace StructGen.Objects
{
    public class GeneratorInterface
    {
        /// <summary>enum for available header types that can be created</summary>
        public enum HEADER_TYPE
        {
            C,
            CPP,
            CSHARP,
        }

        readonly static string autogenHeader =
        "/////////////////////////////////////////////////////////////////\r\n" +
        "//! This file is auto-generated by StructGen \r\n" +
        "/////////////////////////////////////////////////////////////////\r\n\n";

        /// <summary>enum for acceptable variable types</summary>
        static readonly List<string> validTypes = new List<string>
        {
            "int",
            "int8_t",
            "int16_t",
            "int32_t",
            "unsigned int",
            "uint",
            "uint8_t",
            "uint16_t",
            "uint32_t",
            "float",
            "double",
            "std::string",
            "string",
            "char",
            "unsigned char",
            "signed char",
        };

        /// <summary>Handles CSV file input</summary>
        /// <param name="filepath"> -[in]- Filepath of the file to parse</param>
        /// <returns>Parsed HeaderFile structure</returns>
        public static HeaderFile HandleCsvFile(string filepath)
        {
            return new HeaderFile();
        }

        /// <summary>Handles JSON file input</summary>
        /// <param name="filepath"> -[in]- Filepath of the file to parse</param>
        /// <returns>Parsed HeaderFile structure</returns>
        public static HeaderFile HandleJsonFile(string filepath)
        {
            string json = File.ReadAllText(filepath);
            return JsonConvert.DeserializeObject<HeaderFile>(json);
        }

        /// <summary>Handles XML file input</summary>
        /// <param name="filepath"> -[in]- Filepath of the file to parse</param>
        /// <returns>Parsed HeaderFile structure</returns>
        public static HeaderFile HandleXmlFile(string filepath)
        {
            return new HeaderFile();
        }

        /// <summary>Validates the variables in a file structure are acceptable</summary>
        /// <param name="file"> -[in]- File structure to be validated</param>
        /// <returns>A list of variable names with improper types</returns>
        private static List<string> ValidateVariableTypes(HeaderFile file)
        {
            List<string> invalidVariables = new List<string>();

            foreach (var structure in file.Structures)
            {
                foreach (var variable in structure.Variables)
                {
                    if (!validTypes.Contains(variable.Type))
                    {
                        invalidVariables.Add(variable.Name);
                    }
                }
            }

            return invalidVariables;
        }

        /// <summary>Creates a header for C language</summary>
        /// <param name="file"> -[in]- File structure to be created</param>
        /// <returns>string of output file content</returns>
        public static string GenerateHeaderC(HeaderFile file)
        {
            StringBuilder output = new StringBuilder();

            output.AppendLine(autogenHeader);

            List<string> invalidVars = ValidateVariableTypes(file);

            if (invalidVars.Count == 0)
            {
                foreach (var structure in file.Structures)
                {
                    // Define the structure
                    output.AppendLine($"/* {structure.StructureComment} */");
                    output.AppendLine($"struct {structure.StructureName}");
                    output.AppendLine("{");

                    // Define variables
                    foreach (var variable in structure.Variables)
                    {
                        output.AppendLine($"    {variable.Type} {variable.Name}; /* {variable.Comment} */");
                    }

                    // Close the structure definition
                    output.AppendLine("};\n\n");
                }
            }
            else
            {
                // respond with which variables are invalid
                output.AppendLine("\n\nBad input file variable types on variables:\n");

                foreach (var invalidVar in invalidVars)
                {
                    output.AppendLine(invalidVar);
                }
            }

            return output.ToString();
        }

        /// <summary>Creates a header for C++ language</summary>
        /// <param name="file"> -[in]- File structure to be created</param>
        /// <returns>string of output file content</returns>
        public static string GenerateHeaderCPP(HeaderFile file)
        {
            StringBuilder output = new StringBuilder();

            output.AppendLine(autogenHeader);
            output.AppendLine("/////////////////////////////////////////////////////////////////");
            output.Append($"\t@project: {file.File.ProjectName}\n");
            output.Append($"\t@name:    {file.File.FileName}\n");
            output.Append($"\t@version: {file.File.FileVersion}\n");
            output.AppendLine("/////////////////////////////////////////////////////////////////");
            output.AppendLine("#include <string>");
            output.AppendLine("#include <cstdint>");
            output.AppendLine("\n\n");

            List<string> invalidVars = ValidateVariableTypes(file);

            if (invalidVars.Count == 0)
            {
                foreach (var structure in file.Structures)
                {
                    bool packed = false;
                    // Define the structure
                    output.AppendLine($"/// @brief {structure.StructureComment}");

                    // Check if Packing is not "0" and not empty
                    if (!string.IsNullOrEmpty(structure.StructurePacking) && structure.StructurePacking != "0")
                    {
                        // Define the structure with custom packing
                        output.AppendLine($"#pragma pack(push,{structure.StructurePacking})");
                        packed = true;
                    }

                    output.AppendLine($"struct {structure.StructureName}");
                    output.AppendLine("{");

                    // Define variables
                    foreach (var variable in structure.Variables)
                    {
                        output.AppendLine($"    {variable.Type} {variable.Name}; // {variable.Comment}");
                    }

                    // Close the structure definition
                    output.AppendLine("};");

                    if(packed)
                    {
                        output.AppendLine($"#pragma pack(pop)\n");
                    }

                    output.AppendLine("");
                }
            }
            else
            {
                // respond with which variables are invalid
                output.AppendLine("\n\nBad input file variable types on variables:\n");

                foreach (var invalidVar in invalidVars)
                {
                    output.AppendLine(invalidVar);
                }
            }

            return output.ToString();
        }

        /// <summary>Creates a header for C# language</summary>
        /// <param name="file"> -[in]- File structure to be created</param>
        /// <returns>string of output file content</returns>
        public static string GenerateHeaderCSHARP(HeaderFile file)
        {
            StringBuilder output = new StringBuilder();

            output.AppendLine(autogenHeader);
            output.AppendLine("using System;");
            output.AppendLine("using System.Runtime.InteropServices;");
            output.AppendLine("\n");

            List<string> invalidVars = ValidateVariableTypes(file);

            if (invalidVars.Count == 0)
            {
                foreach (var structure in file.Structures)
                {
                    // Define the structure 
                    output.AppendLine($"/// <summary> {structure.StructureComment} </summary>");
                    output.AppendLine($"[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]");
                    output.AppendLine($"public struct {structure.StructureName}");
                    output.AppendLine("{");

                    // Define variables
                    foreach (var variable in structure.Variables)
                    {
                        output.AppendLine($"    public {variable.Type} {variable.Name}; // {variable.Comment}");
                    }

                    // Close the structure definition
                    output.AppendLine("}\n");
                }
            }
            else
            {
                // respond with which variables are invalid
                output.AppendLine("\n\nBad input file variable types on variables:\n");

                foreach (var invalidVar in invalidVars)
                {
                    output.AppendLine(invalidVar);
                }
            }

            return output.ToString();
        }

        public static void GenerateFileDescriptionDocument(HeaderFile file)
        {
            // @todo
        }
    }
}
